磁盘io： input/output

服务器的瓶颈所在

机械磁盘：
  盘片： 相同容量下，盘片越少越好。单片最好。
  接口： IDE：PATA   基本被淘汰，并口磁盘
	 SATA串口磁盘 SATA1,1.5Gbit/s   SATA2 3Gbit/s   SATA3 6Gbit/s = 768Mbyte/s
	 SCSI  SAS【串行scsi磁盘】  服务器磁盘。   FC
	服务器磁盘： 价格昂贵， 可热插拔。
		阵列，不要轻易拔插磁盘。
  转速：5400  7200   10000  15000
       	家用硬盘不使用高转速的原因：降低功耗。降低噪音。提高寿命。
	服务器硬盘：稳定，7 X 24 工作。
  容量：1T 以上    byte   k、M、G、T、P、E、Z、Y、B    BB
  缓存：16M 32M	
   1. 预读取，数据一般连续存放到磁盘中。磁盘读取当前数据的时候会预先将后面连续的数据放入缓存。提高读取速度。
   2. 对写入动作进行缓存，进行排序、合并请求。最后再向磁盘写入。
   3. 临时存储最近访问过的数据。
  IO： IOPS，每秒输入+输出的次数。 一般磁盘寻址时间在6MS左右。机械硬盘一般的IOPS在：
								SCSI\SAS : 110 - 130
								SATA: 60-80
  吞吐量：数据吞吐量，单位时间的数据写入+读取大小。r byte/s + w byte/s

	

固态硬盘：850pro SATA3 550M/s 100K
  寿命，擦写1000次

flash
M.2：

===================================================================================

linux  一切皆文件

vfs:虚拟文件系统。
dentry: 目录项  将文件路径名与 inode进行关联
inode： 能够找到数据块所在位置。
block： 存放数据。

du -h     统计目录(或文件)所占磁盘空间的大小
ll  ls -l    长格式的形式查看当前目录下所有可见文件的详细属性
fdisk -l  查看系统磁盘信息
df -Th   查看磁盘空间
dumpe2fs /dev/sda1 -h  显示当前的磁盘状态

问题：
如果你的磁盘不能写入数据了？如何排错。
1 权限，磁盘配额
2 磁盘空间
3 磁盘是否坏了
4 磁盘挂载问题
5 i节点是否够用


磁盘调度算法：
cat /sys/block/sdX/queue/scheduler   
noop anticipatory deadline [cfq]

deadline  保证对目前所有IO请求以最小延迟方式进行处理。大多数web  、 mysql数据库应用都使用这种算法。

1   10    60
2 + 10
60  10  1
120 + 10 130
running +　60 + 10 + 1 

生活中都是先入先出

CFQ：  维护一个公平IO队列，所有请求完全公平，轮询进行处理。
anticipatory： 对于当前请求，系统会去预测你接下来的请求是什么，这种方式对于大量随机读写的操作，将很慢。一般下载服务器使用这种算法。
noop： FIFO ， first in first out，针对读写速度快的磁盘使用。一般固态硬盘使用。

修改：
echo deadline > /sys/block/sdX/queue/scheduler 

echo 4096 > /sys/block/sdX/queue/nr_requests   IO请求队列的长度。128。

echo 4096 > /sys/block/sdX/queue/read_ahead_kb   磁盘对于IO请求增加预读取的数据量，128Kb。



====================================================================================
 yum install -y sysstat
iostat


iostat -d -k
Linux 2.6.32-573.el6.x86_64 (localhost)         06/20/2017      _x86_64_        (1 CPU)

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda               0.64        10.87         1.77     111190      18104

tps 每秒传输次数。每秒读次数+写次数。与IOPS相同。
kB_read/s + kB_wrtn/s = 吞吐量

iostat -d -x
Linux 2.6.32-573.el6.x86_64 (localhost)         06/20/2017      _x86_64_        (1 CPU)

Device:         rrqm/s   wrqm/s     r/s     w/s   rsec/s   wsec/s avgrq-sz avgqu-sz   await  svctm  %util
sda               0.16     0.28    0.47    0.15    20.86     3.45    39.30     0.06   96.71   5.03   0.31


rrqm/s     每秒合并的读请求数量。
wrqm/s    每秒合并的写请求数量。
r/s            每秒读次数
w/s    	每秒写次数
rkB/s       每秒读速度
wkB/s     每秒写速度
avgrq-sz   平均请求大小
avgqu-sz  平均队列的大小
await        处理IO请求的平均时间【包含处理过程中的等待时间】。单位MS。
svctm       系统处理IO请求的平均时间，不包含等待时间。await - svctm = io等待时间
%util	数值越大，表示磁盘IO越忙。


求平均吞吐量：
iostat -dxk 1 10 | grep -w 'sda' | awk '{print $6+$7}'| awk '{sum += $1}END{print sum/10}'
191.174


yum install -y iotop
iotop   可以查看哪个程序占用了大量的磁盘io


mysql读写分离， 数据库压力都在磁盘IO
一般做数据库服务器，将内存调整很大。


iostat  查看当前磁盘io是否有问题。
如果真的是io有问题，我们可以通过iotop命令查看具体哪个程序有问题。
找程序日志。
定位为什么会耗费大量磁盘io。

如果就是用户量增大，服务器压力增高。 解决办法：增加集群规模
如果有坏人执行耗费磁盘io的命令。 解决办法：修改密码，清理非法用户。
    程序有bug，运维首先需要考虑，保证服务正常运行。
			        研发出方案解决bug。


=======================================================================================

1  关闭atime
/dev/mapper/VolGroup-lv_root /                       ext4    defaults,noatime,nodiratime        1 1

2  提高文件系统版本：ext4
ext2  ext3  ext4
ext3 相对于 ext2 有一个日志功能。

Linux kernel 自 2.6.28 开始正式支持新的文件系统 Ext4。 Ext4 是 Ext3 的改进版，修改了 Ext3 中部分重要的数据结构，而不仅仅像 Ext3 对 Ext2 那样，只是增加了一个日志功能而已。Ext4 可以提供更佳的性能和可靠性，还有更为丰富的功能：
1. 与 Ext3 兼容。 执行若干条命令，就能从 Ext3 在线迁移到 Ext4，而无须重新格式化磁盘或重新安装系统。原有 Ext3 数据结构照样保留，Ext4 作用于新数据，当然，整个文件系统因此也就获得了 Ext4 所支持的更大容量。
2. 更大的文件系统和更大的文件。 较之 Ext3 目前所支持的最大 16TB 文件系统和最大 2TB 文件，Ext4 分别支持 1EB（1,048,576TB， 1EB= 1024PB， 1PB=1024TB）的文件系统，以及 16TB 的文件。
3. 无限数量的子目录。 Ext3 目前只支持 32,000 个子目录，而 Ext4 支持无限数量的子目录。
4. Extents。 Ext3 采用间接块映射，当操作大文件时，效率极其低下。比如一个 100MB 大小的文件，在 Ext3 中要建立 25,600 个数据块（每个数据块大小为 4KB）的映射表。而 Ext4 引入了现代文件系统中流行的 extents 概念，每个 extent 为一组连续的数据块，上述文件则表示为“该文件数据保存在接下来的 25,600 个数据块中”，提高了不少效率。
5. 多块分配。 当写入数据到 Ext3 文件系统中时，Ext3 的数据块分配器每次只能分配一个 4KB 的块，写一个 100MB 文件就要调用 25,600 次数据块分配器，而 Ext4 的多块分配器“multiblock allocator”（mballoc） 支持一次调用分配多个数据块。
6. 延迟分配。 Ext3 的数据块分配策略是尽快分配，而 Ext4 和其它现代文件操作系统的策略是尽可能地延迟分配，直到文件在 cache 中写完才开始分配数据块并写入磁盘，这样就能优化整个文件的数据块分配，与前两种特性搭配起来可以显著提升性能。
7. 快速 fsck。 以前执行 fsck 第一步就会很慢，因为它要检查所有的 inode，现在 Ext4 给每个组的 inode 表中都添加了一份未使用 inode 的列表，今后 fsck Ext4 文件系统就可以跳过它们而只去检查那些在用的 inode 了。
8. 日志校验。 日志是最常用的部分，也极易导致磁盘硬件故障，而从损坏的日志中恢复数据会导致更多的数据损坏。Ext4 的日志校验功能可以很方便地判断日志数据是否损坏，而且它将 Ext3 的两阶段日志机制合并成一个阶段，在增加安全性的同时提高了性能。
9. “无日志”（No Journaling）模式。 日志总归有一些开销，Ext4 允许关闭日志，以便某些有特殊需求的用户可以借此提升性能。
10. 在线碎片整理。 尽管延迟分配、多块分配和 extents 能有效减少文件系统碎片，但碎片还是不可避免会产生。Ext4 支持在线碎片整理，并将提供 e4defrag 工具进行个别文件或整个文件系统的碎片整理。
11. inode 相关特性。 Ext4 支持更大的 inode，较之 Ext3 默认的 inode 大小 128 字节，Ext4 为了在 inode 中容纳更多的扩展属性（如纳秒时间戳或 inode 版本），默认 inode 大小为 256 字节。Ext4 还支持快速扩展属性（fast extended attributes）和 inode 保留（inodes reservation）。
12. 持久预分配（Persistent preallocation）。 P2P 软件为了保证下载文件有足够的空间存放，常常会预先创建一个与所下载文件大小相同的空文件，以免未来的数小时或数天之内磁盘空间不足导致下载失败。 Ext4 在文件系统层面实现了持久预分配并提供相应的 API（libc 中的 posix_fallocate()），比应用软件自己实现更有效率。
13. 默认启用 barrier。 磁盘上配有内部缓存，以便重新调整批量数据的写操作顺序，优化写入性能，因此文件系统必须在日志数据写入磁盘之后才能写 commit 记录，若 commit 记录写入在先，而日志有可能损坏，那么就会影响数据完整性。Ext4 默认启用 barrier，只有当 barrier 之前的数据全部写入磁盘，才能写 barrier 之后的数据。（可通过 "mount -o barrier=0" 命令禁用该特性。）

=============================================================================================

vmstat
procs --------memory【单位kb】--- ---swap[kb/s]-- -io【单位block】- --system-- -----cpu-----
 r  b   swpd   free   buff  cache   si   so        bi    bo          in   cs    us sy id wa st
 0  0      0 1779008   7152  49788   0    0        70     1          22   32    0  0 98  1  0

r	处于运行状态的进程
b	处于阻塞状态的进程block

swpd    使用swap的虚拟内存大小。

si	从swap换入到内存
so      从内存换出到swap

bi	从block设备写入内存  一个块 1024byte
bo	从内存写回block设备

in	中断次数
cs	上下文切换次数

st	steal时间，虚拟机偷取时间。

=========================================================================================

QPS 每秒查询次数。数据库。

svn  保存代码的工具。版本控制系统。

svnserver:/projectA/

1.0 版本
projectA/worker1   projectA/worker2   projectA/worker3  ........ 协同开发 

worker1 更新 commit 数据到版本库, 添加注释，做了哪些修改。
2.0 版本

运维可以拿来使用：
利用svn保存，脚本，配置文件，程序包。



windows：图形化svn工具。

============================================================================







